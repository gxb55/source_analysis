# 锁升级
1. 无锁;不加锁的状态
2. 偏向锁；指向持有锁的线程id，记录在对象的对象头上 锁升级到轻量级锁；偏向锁的撤销需要等到全局安全点，持有偏向锁的线程
    不会自己释放偏向锁，需要有线程过来竞争的时候才会释放；偏向锁的撤销需要到安全点，安全点撤销锁会影响效率，默认是禁用的状态；
   1. 不会自动释放，要到安全点才会释放，安全点导致性能降低，在a执行完b执行的情况下会是偏向锁；
   2. 偏向锁不会上来就开始，需要等待4s之后才行，如果对象用过hash则调过偏向锁，因为mark word上面记录不了那么多的信息； 
3. 轻量级锁；指向持有锁的线程的lock record上面；轻量级锁是自旋，自旋到一定次数升级为重量级锁；
   1. 指向栈帧的lock record，lock record里面记录的是锁对象的mark word信息；
   2. lock record 并非是一个，而是一个集合这样应对锁重入的问题；
   3. 如果持有轻量级锁的时候有线程过来竞争，自旋了10次还没有持有锁就会锁升级到重量级锁； 
   4. 00
4. 重量级锁；指向monitor对象；
   1. jdk1.6 之后引入；
   2. 线程上下文切换，其实是多个线程切换，如果是多核其实就是不同的线程在不同的cpu上来回切换；
   3. 10次自旋
   
# 红黑树
1. 不是红节点就是黑节点
2. 最长子树的边和最短子树的边长度不会超过二倍；
3. 根节点是黑节点，每个为null的叶子节点也是黑节点；
4. 红节点的孩子节点必须是黑节点；

# redis
1. 分布式锁
   1. 锁的是锁的名称，hash结构，key是线程id，val是重入次数；
   2. 首先判断锁是否存在，不存在就设置；其次判断key是否存在，存在就重入次数+1，否则就返回hash的剩余时间；
   3. 加锁成功，就用看门狗，隔一定时间给锁续期；默认加锁加30s，每个10s timer跑一次给锁续期；续期也是lua脚本；
   4. 解锁；是删除这个hash结构，解锁会判断是释放锁，还是某次重入的结束；
   5. 解锁，会通过channel发送msg，前面等待锁的会唤醒，然后再去抢锁；
2. 幂等锁
   1. redis设置一个key 然后设置过期时间，下次请求来的时候判断key是否存在，如果存在就说明执行过了返回；
   2. 数据库主键id幂等；
3. 缓存
   1. 缓存雪崩，大量key同时失效，缓存不存在，数据库存在；
   2. 缓存击穿，某些热key缓存失效，缓存不存在，数据库存在；
   3. 缓存穿透，缓存不存在，数据库也不存在，非法的请求，布隆过滤器；
4. 集群架构
   1. 主从集群模式；
   2. 哨兵模式；
   3. 集群分片模式 16384
5. 数据类型，底层实现；
   1. string 动态字符串
   2. hash 压缩链表 hash散列表
   3. list 压缩链表 双向链表
   4. set  数组 散列表
   5. zset 压缩列表 跳表
# AQS
1. 抽象队列同步器，state，node，双向链表。
2. 公平锁，非公平锁，区别在于公平锁判断队列中有排队的线程就等待入队，非公平锁直接尝试持有锁
3. 先尝试获取锁，1.当前资源没有抢占，即state=0，则cas获取锁； 
4. 2.当前线程持有锁，就重入；
5. 当前线程要排队了，没有队列就初始化，有队列就入队，入队之后自旋，然后park自己；
6. 解锁也是同样的看是锁的重入，还是解锁，如果是解锁，就设置state为0，然后找到下个等待的节点，unpark
# JVM
# SQL调优
1. explain关键字查看，看是否走索引，看是否产生临时表；
2. 联合索引，最左前缀原则；
3. 模糊匹配，通配符以%开头；
4. 数据格式转化；
5. 小表驱动大表，节省连接数；
6. or 两个条件都要有索引才会命中
7. 删除和更新不走索引导致锁表；
# 树
1. 二叉树，两个分叉的数，左子树，右子树，父节点；
2. bst，Binary Sort Tree，二叉搜索树，左子树《根节点《右子树，容易退化成链表；
3. avl，二叉搜索平衡树，会自旋，左子树和右子树高度差不超过1；
4. 红黑树，见上面解析
5. b树，其实是多叉树，叶子节点和非叶子节点都保存数据，叶子节点之间没有联通，查询的效率是logn
6. b+树，mysql的索引；
   1. 非叶子节点只保存索引，不保存数据，能够保存更多的数据，树的层数就会很低
   2. 叶子节点保存数据，
   3. 叶子节点有指针进行顺序链接；
# IO
1. BIO
2. NIO
# reactor
1. 单reactor，单线程，一个线程处理链接和业务逻辑，负责链接然后dispatch到不同的事件上，业务的处理影响reactor的链接和读写
2. 单reactor，多线程，一个线程负责链接和读写，业务逻辑使用线程池处理，即reactor链接之后读取数据，线程池处理业务逻辑，reactor线程写数据；
3. 主从reactor，多线程，一个线程负责链接，链接之后得到socketChannel，子reactor线程负责读写，业务逻辑交给单独的线程处理；
# select poll epoll
1. 首先这三个都是linux系统底层的方法，io多路复用技术，用来监听文件描述符的就绪事件；
2. select
   1. 需要O（N）的时间复杂度去遍历查询哪个文件描述符就绪；
   2. 会有文件描述符大小的限制；1024个；
   3. rset的数据类型是bitmap，rset不可重复使用，每次都是新的；
   4. 涉及到内核态到用户态数据的copy；bitmap来回copy
3. poll
   1. 基于数组实现，没有了大小的限制；
   2. 依旧需要copy从内核态到用户态；
   3. 主要的改动就是使用了结构体，每次不用重新创建rset，这里是用的pollfd的结构体，文件描述符，event，revent，每次的事件和重置都依赖revent
4. epoll
   1. 就是even poll epoolawait会返回就绪的文件描述符个数，然后重排，所以只需要处理前几个就可以了；
   2. 使用内存映射技术，就不用来回copy，共享内存；
   3. 水平触发 边缘触发；
