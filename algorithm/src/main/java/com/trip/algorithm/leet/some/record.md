# BFS(宽度优先搜索)
1. 从某个位置一圈一圈的往外找，某些时候要把他们打上标记比如最大人工岛；
2. 某些情况回溯的时候也可以考虑宽度优先遍历，在遍历的过程中寻找题目的答案；
3. 宽度优先遍历一般用队列，前面出，后面入；

## 827. 最大人工岛
> 标记每个岛的大小，然后遍历地图的非岛位置，然后将非岛位置的上下左右计算上即可得到结果，求一个
> 最大值
************
## 994. 腐烂的橘子
>直接用队列实现，每次入队，出队之后计算影响值，影响值入队，直到队列为空。
*********************
## 1020. 飞地的数量
> 套用最大人工湖，给每个飞地标号，然后标号的过程中存储他是否连接边界，简单的可以直接从边界的飞地出发
> 减少计算过程，如果从边界出发没有被标记则认为是不符合要求的最后计算返回；
## 301. 删除无效的括号
> DFS + 同层剪枝，即每个字母都可以去或者不去，这就是回溯，回溯要加剪枝，不然过不去
> BFS 首先整个的串，先去掉一个字母然后继续BFS，去掉两个字符，去掉三个字符，依次往后走
> 当发现合法的时候就停止，因为是一层一层走的，这个时候合法后面的都不用看了，耗时较少，算法
> 比较优秀；

# 单调栈
1. 从后向前遍历，单调递增，单调栈的核心是出栈的元素都不会被用到，新增的元素替代了栈中原有元素，被替代的其实
    是无效的数据；
2. 根据单调栈的特性考虑是否适用于某些题目；
## 1019. 链表中的下一个更大节点
> 考察点，链表遍历；单调栈，从后向前遍历，栈顶位置小，栈底位置数据大，每次添加数据的
> 时候会判断是否能够维持单调递增栈，如果要添加的数据大，则栈中数据不断的出栈，直到栈中元素大于当前元素
> 或者栈为空的情况

## 901. 股票价格跨度
> 基本上说是单调栈的模板题目，主要是考虑数组压缩，删除的都是无用的；